{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#
# Smart Contract Implementing Bonds Auction in the Orderbook of Neutrino Protocol 
#

#-------------------Constants---------------------------
let WAVES = "WAVES"
let SEPARATOR = ","
#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    valueOrElse(getInteger(this, key), 0)
}
func getStringByKey(key: String) = {
    valueOrElse(getString(this, key), "")
}
func getStringByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getString(contract, key), "")
}
func getNumberByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getInteger(contract, key), 0)
}


#------Order statuses------
let NONE = 0
let NEW = 1
let REJECTED = 2
let SUCCESS = 3
let RETURNED = 4

let LOCK = 0
let BURN = 1

let INTERNAL = 1
let EXTERNAL = 2
#-------------------Constructo--------------------------
let ValidatorsKey = "validator"
#let BftCoefficientKey = "bft_coefficient"
let RequestTimeoutKey = "rq_timeout"
let FeeKey = "fee"
let RandomContractAddressKey = "random_contact_address"
# erc20_address_WAVES = ercTokenAddress
# asset_type__WAVES = 0 (NativeToken)
# asset_status_WAVES = 3 (SUCCESS)
# asset_decimals__WAVES = 8 

#-------------------Keys--------------------------------
let FirstElementKey = "first_element"
let LastElementKey = "last_element"

let TimeoutNewRoundKey = "timeout_new_round"
let RoundEndKey = "round_end"
let RandomKey = "random_key"

func getRqStatusKey(requestId: String) = "status_" + requestId
func getRqAssetIdKey(requestId: String) = "asset_id_" + requestId
func getRqHeightKey(requestId: String) = "height_" + requestId
func getRqOwnerKey(requestId: String) = "owner_" + requestId
func getRqTargetKey(requestId: String) = "target_" + requestId
func getRqAmountKey(requestId: String) = "amount_" + requestId

func getStatusInternalRqKey(requestId: String) = "status_internal_rq_" + requestId

func getNextRqKey(requestId: String) = "next_rq_" + requestId
func getPrevRqKey(requestId: String) = "prev_rq_" + requestId


func getERC20ByAssetIdKey(assetId: String) = "erc_20_" + assetId
func getAssetIdByERC20Key(erc20Address: String) = "asset_id_" + erc20Address
func getTypeByERC20Key(erc20Address: String) = "erc_20_status_" + erc20Address

#-------------------Global vars-------------------------
let validators = getStringByKey(ValidatorsKey).split(",")
#let bftCoefficient = getNumberByKey(BftCoefficientKey)
let firstElement = getStringByKey(FirstElementKey)
let lastElement = getStringByKey(LastElementKey)
let requestTimeout = getNumberByKey(RequestTimeoutKey)
let fee = getNumberByKey(FeeKey)
let randomContractAddress = addressFromStringValue(getStringByKey(RandomContractAddressKey))
let timeoutNewRound = getNumberByAddressAndKey(randomContractAddress, TimeoutNewRoundKey)
let roundEnd = getNumberByAddressAndKey(randomContractAddress, RoundEndKey)
let random = getStringByAddressAndKey(randomContractAddress, RandomKey)

#-------------------Get functions----------------------
func getRqStatus(requestId: String) = getNumberByKey(getRqStatusKey(requestId))
func getRqOwner(requestId: String) = getStringByKey(getRqOwnerKey(requestId))
func getRqTarget(requestId: String) = getStringByKey(getRqTargetKey(requestId))
func getRqAmount(requestId: String) = getNumberByKey(getRqAmountKey(requestId))
func getRqAssetId(requestId: String) = getStringByKey(getRqAssetIdKey(requestId))
func getRqHeight(requestId: String) = getNumberByKey(getRqHeightKey(requestId))
func getStatusInternalRq(requestId: String) = getNumberByKey(getStatusInternalRqKey(requestId))
# List
# 0 - 1 - 2 - 3
# next counter+1
func getNextRq(requestId: String) = getStringByKey(getNextRqKey(requestId))
func getPrevRq(requestId: String) = getStringByKey(getPrevRqKey(requestId))

func getERC20ByAssetId(assetId: String) = getStringByKey(getERC20ByAssetIdKey(assetId))
func getAssetIdByERC20(erc20Address: String) = getStringByKey(getAssetIdByERC20Key(erc20Address))
func getTypeByERC20(erc20Address: String) = getNumberByKey(getTypeByERC20Key(erc20Address))

func isRqPastDue(requestId: String) = {
    height > (getRqHeight(requestId) + requestTimeout)
}


#-------------------Other function---------------------

func indexToString(index: Int) = {
    "|" + toString(index) + "|"
}

func getDropedList(freeValidators: List[Int], dropIndex: Int) = {
    [] 
        ++ (if size(freeValidators) > 0 && freeValidators[0] == dropIndex then [] else [ freeValidators[0] ]) 
        ++ (if size(freeValidators) > 1 && freeValidators[1] == dropIndex then [] else [ freeValidators[1] ]) 
        ++ (if size(freeValidators) > 2 && freeValidators[2] == dropIndex then [] else [ freeValidators[2] ]) 
        ++ (if size(freeValidators) > 3 && freeValidators[3] == dropIndex then [] else [ freeValidators[3] ]) 
        ++ (if size(freeValidators) > 4 && freeValidators[4] == dropIndex then [] else [ freeValidators[4] ]) 
}

func isValidSigns(msg: String, signsString: String) = {
    let bytesRandom = fromBase58String(random)
    let randomValues = [
        toInt(take(bytesRandom, 8)),
        toInt(take(drop(bytesRandom, 8),8)),
        toInt(take(drop(bytesRandom, 16),8))
    ]

    let startValidators = [
        0,
        1,
        2,
        3,
        4
    ]

    let firstValidatorIndex = randomValues[0] % 5
    let validatorsOne = getDropedList(startValidators, firstValidatorIndex)
    let twoValidatorIndex =  randomValues[1] % 4

    let validatorsTwo = getDropedList(startValidators, firstValidatorIndex)
    let threeValidatorIndex = randomValues[2] % 3


    let one = startValidators[firstValidatorIndex]
    let two = validatorsOne[twoValidatorIndex]
    let three = validatorsTwo[threeValidatorIndex]
    
    let signs = signsString.split(",")
    let count = 
        (if sigVerify(toBytes(msg), fromBase58String(signs[one]), fromBase58String(validators[one])) then 1 else 0) +
        (if sigVerify(toBytes(msg), fromBase58String(signs[two]), fromBase58String(validators[two])) then 1 else 0) +
        (if sigVerify(toBytes(msg), fromBase58String(signs[three]), fromBase58String(validators[three])) then 1 else 0) 

    count > 3
}

#-------------------Callable---------------------------

@Callable(i)
func mint(rqHash: String, erc20Address: String, owner: String, amount: Int, signsString: String, initDataOrNull: String) = {
    let msg = toBase58String(keccak256(toBytes(rqHash + "_" + erc20Address + "_" + owner + "_" + toString(amount) + "_" + initDataOrNull + "_" + toString(EXTERNAL))))
    if getStatusInternalRq(rqHash) == SUCCESS
        then throw("invalid status")
    else if !isValidSigns(msg, signsString)
        then throw("invalid signs")
    else {
        let storageAssetId = getAssetIdByERC20(erc20Address)
        let dataArgs = initDataOrNull.split(SEPARATOR)
        let issue = if storageAssetId == "" then Issue(dataArgs[0], dataArgs[1], 2, parseIntValue(dataArgs[2]), true, unit, 0) else unit

        let assetId = if storageAssetId == "" then toBase58String(calculateAssetId(value(issue))) else storageAssetId
        let assetCreateResult = 
            if storageAssetId == "" 
                then 
                    [
                        StringEntry(getAssetIdByERC20Key(erc20Address), assetId),
                        StringEntry(getERC20ByAssetIdKey(assetId), erc20Address),
                        IntegerEntry(getTypeByERC20Key(erc20Address), EXTERNAL)
                    ] :+ value(issue)
            else []
        
        [
            Reissue(fromBase58String(assetId), true, amount),
            ScriptTransfer(addressFromStringValue(owner), amount, fromBase58String(assetId)),
            IntegerEntry(getStatusInternalRqKey(rqHash), SUCCESS)
        ] ++ assetCreateResult
    }
}


@Callable(i)
func unlock(rqHash: String, erc20Address: String, assetIdOrNull: String, owner: String, amount: Int, signsString: String) = {
    let msg = toBase58String(keccak256(toBytes(rqHash + "_" + erc20Address + "_" + owner + "_" + toString(amount) + "_" + assetIdOrNull + "_" + toString(INTERNAL))))
    if getStatusInternalRq(rqHash) == SUCCESS 
        then throw("invalid status")
    else if !isValidSigns(msg, signsString)
        then throw("invalid signs")
    else if getERC20ByAssetId(erc20Address) != "" && getTypeByERC20(erc20Address) != INTERNAL
        then throw("Invalid erc20. Use mint func.")
    else {
        let storageAssetId = getAssetIdByERC20(erc20Address)
        if storageAssetId == ""  && assetIdOrNull == ""
            then throw("invalid assetId")
        else {
            let assetId = if storageAssetId == "" then assetIdOrNull else storageAssetId
            let assetCreateResult = 
                if storageAssetId == "" 
                    then 
                        [
                            StringEntry(getAssetIdByERC20Key(erc20Address), assetId),
                            StringEntry(getERC20ByAssetIdKey(assetId), erc20Address),
                            IntegerEntry(getTypeByERC20Key(erc20Address), INTERNAL)
                        ]
                else []
        
            [
                ScriptTransfer(addressFromStringValue(owner), amount, if assetId == WAVES then unit else fromBase58String(assetId)),
                IntegerEntry(getStatusInternalRqKey(rqHash), SUCCESS)
            ] ++ assetCreateResult
        }
    }
}

@Callable(i)
func createBurnRequest(target: String) = {
    let pmtSwap = extract(i.payments[0]);
    let pmtFee = extract(i.payments[1]);

    let requestId = toBase58String(keccak256(fromBase58String(toString(this)) + i.caller.bytes + i.transactionId + toBytes(target)))

    let assetId = if isDefined(pmtSwap.assetId) then toBase58String(value(pmtSwap.assetId)) else WAVES
    let amount =  pmtSwap.amount 
    let owner = toString(i.caller)

    if (!isDefined(pmtFee.assetId))
        then throw("invalid fer asset")
    else if (pmtFee.amount < fee)
        then throw("invalid fer asset")
    else if(getRqOwner(requestId) != "")
        then throw("request exists")
    else if(amount == 0)
        then throw("invalid amount")
    else {
        [
            StringEntry(FirstElementKey, if firstElement == "" then requestId else firstElement),
            StringEntry(getNextRqKey(lastElement), if firstElement == "" then "" else requestId),
            StringEntry(getPrevRqKey(requestId), if firstElement == "" then "" else requestId),
            StringEntry(LastElementKey, requestId),

            IntegerEntry(getRqStatusKey(requestId), NEW),
            StringEntry(getRqOwnerKey(requestId), owner),
            StringEntry(getRqAssetIdKey(requestId), assetId),

            IntegerEntry(getRqHeightKey(requestId), height),
            StringEntry(getRqTargetKey(requestId), target),
            IntegerEntry(getRqAmountKey(requestId), amount)
        ]
    }
}

@Callable(i)
func changeStatus(requestId: String, signsString: String, status: Int) = {
    if(!isValidSigns(requestId + "_" + toString(status), signsString)) 
        then throw("count is less bftCoefficien")
    else if(getRqOwner(requestId) == "")
        then throw("request is not exists")
    else if(getRqStatus(requestId) != NEW)
        then throw("request is not exists")
    else if(isRqPastDue(requestId))
        then throw("rq expire")
    else if(status != SUCCESS && status != REJECTED)
        then throw("invalid status")
    else {
        let owner = addressFromStringValue(getRqOwner(requestId))
        let amount = getRqAmount(requestId)

        let assetId = getRqAssetId(requestId)
        let transfer = 
            if status == REJECTED
                then [ 
                        ScriptTransfer(addressFromStringValue(getRqOwner(requestId)), getRqAmount(requestId), 
                            if assetId == WAVES then unit else fromBase58String(getRqAssetId(requestId))) 
                     ]
            else []

        [
            IntegerEntry(getRqStatusKey(requestId), status)
            
        ] ++ transfer
    }
}

@Callable(i)
func withdrawPastDueReqest(requestId: String) = {
    if(!isRqPastDue(requestId))
        then throw("rq not expire")
    else if(getRqStatus(requestId) != NEW)
        then throw("request not exists")
    else {
        let assetId = getRqAssetId(requestId)
        [
            IntegerEntry(getRqStatusKey(requestId), RETURNED),
            ScriptTransfer(addressFromStringValue(getRqOwner(requestId)), getRqAmount(requestId), if assetId == WAVES then unit else fromBase58String(getRqAssetId(requestId)))
        ]
    }
}
