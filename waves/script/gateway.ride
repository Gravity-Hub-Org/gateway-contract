{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#
# Smart Contract Implementing Bonds Auction in the Orderbook of Neutrino Protocol 
#

#-------------------Constants---------------------------
let WAVES = "WAVES"
let SEPARATOR = ","
#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    valueOrElse(getInteger(this, key), 0)
}
func getStringByKey(key: String) = {
    valueOrElse(getString(this, key), "")
}
func getStringByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getString(contract, key), "")
}
func getNumberByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getInteger(contract, key), 0)
}


#------Order statuses------
let NONE = 0
let NEW = 1
let REJECTED = 2
let SUCCESS = 3
let RETURNED = 4

let LOCK = 0
let BURN = 1

let NativeToken = 0
let InputToken = 1


#-------------------Constructo--------------------------
let ValidatorsKey = "validator"
#let BftCoefficientKey = "bft_coefficient"
let RequestTimeoutKey = "rq_timeout"
let FeeKey = "fee"
let RandomContractAddressKey = "random_contact_address"
# erc20_address_WAVES = ercTokenAddress
# asset_type__WAVES = 0 (NativeToken)
# asset_status_WAVES = 3 (SUCCESS)
# asset_decimals__WAVES = 8 

#-------------------Keys--------------------------------
let FirstElementKey = "first_element"
let LastElementKey = "last_element"

let TimeoutNewRoundKey = "timeout_new_round"
let RoundEndKey = "round_end"
let RandomKey = "random_key"

func getRqStatusKey(requestId: String) = "status_" + requestId
func getRqAssetIdKey(requestId: String) = "asset_id_" + requestId
func getRqHeightKey(requestId: String) = "height_" + requestId
func getRqOwnerKey(requestId: String) = "owner_" + requestId
func getRqTargetKey(requestId: String) = "target_" + requestId
func getRqAmountKey(requestId: String) = "amount_" + requestId

func getNextRqKey(requestId: String) = "next_rq_" + requestId
func getPrevRqKey(requestId: String) = "prev_rq_" + requestId

func getAssetIdByERC20Key(erc20Address: String) = "asset_id_" + erc20Address
func getAssetDecimalsKey(assetId: String) = "asset_decimals_" + assetId


#-------------------Global vars-------------------------
let validators = getStringByKey(ValidatorsKey).split(",")
#let bftCoefficient = getNumberByKey(BftCoefficientKey)
let firstElement = getStringByKey(FirstElementKey)
let lastElement = getStringByKey(LastElementKey)
let requestTimeout = getNumberByKey(RequestTimeoutKey)
let fee = getNumberByKey(FeeKey)
let randomContractAddress = addressFromStringValue(getStringByKey(RandomContractAddressKey))
let timeoutNewRound = getNumberByAddressAndKey(randomContractAddress, TimeoutNewRoundKey)
let roundEnd = getNumberByAddressAndKey(randomContractAddress, RoundEndKey)
let random = getStringByAddressAndKey(randomContractAddress, RandomKey)

#-------------------Get functions----------------------
func getRqStatus(requestId: String) = getNumberByKey(getRqStatusKey(requestId))
func getRqOwner(requestId: String) = getStringByKey(getRqOwnerKey(requestId))
func getRqTarget(requestId: String) = getStringByKey(getRqTargetKey(requestId))
func getRqAmount(requestId: String) = getNumberByKey(getRqAmountKey(requestId))
func getRqAssetId(requestId: String) = getStringByKey(getRqAssetIdKey(requestId))
func getRqHeight(requestId: String) = getNumberByKey(getRqHeightKey(requestId))

# List
# 0 - 1 - 2 - 3
# next counter+1
func getNextRq(requestId: String) = getStringByKey(getNextRqKey(requestId))
func getPrevRq(requestId: String) = getStringByKey(getPrevRqKey(requestId))

func getAssetIdByERC20(assetId: String) = getStringByKey(getAssetIdByERC20Key(assetId))
func getAssetDecimals(assetId: String) = getNumberByKey(getAssetDecimalsKey(assetId))

func isRqPastDue(requestId: String) = {
    height > (getRqHeight(requestId) + requestTimeout)
}


#-------------------Other function---------------------

func indexToSting(index: Int) = {
    "|" + toString(index) + "|"
}

func maxByIndex(aIndex: Int, bIndex: Int, values: List[Int]) = {
    let aValue = if aIndex == -1 then -1000 else values[aIndex]
    let bValue = if bIndex == -1 then -1000 else values[bIndex]
    if  aValue == bValue then {
        if aValue % 2 == 0 then aIndex else bIndex
    } else if aValue > bValue then aIndex else bIndex
}

func topWithDrop(dropIndexs: String, randomValues: List[Int]) = {
    let indexs = [
        if contains(dropIndexs, indexToSting(0)) then -1 else 0,
        if contains(dropIndexs, indexToSting(1)) then -1 else 1,
        if contains(dropIndexs, indexToSting(2)) then -1 else 2,
        if contains(dropIndexs, indexToSting(3)) then -1 else 3,
        if contains(dropIndexs, indexToSting(4)) then -1 else 4
    ]

    maxByIndex(maxByIndex(maxByIndex(maxByIndex(indexs[0], indexs[1], randomValues), indexs[2], randomValues), indexs[3], randomValues), indexs[4], randomValues)
}


func isValidSigns(msg: String, signsString: String) = {
    let bytesRandom = fromBase58String(random)
    let randomValues = [
        toInt(bytesRandom.take(1)),
        toInt(bytesRandom.drop(1).take(1)),
        toInt(bytesRandom.drop(2).take(1)),
        toInt(bytesRandom.drop(3).take(1)),
        toInt(bytesRandom.drop(4).take(1))
    ]

    let firstIndex = topWithDrop("", randomValues)
    let twoIndex = topWithDrop(indexToSting(firstIndex), randomValues)
    let threeIndex = topWithDrop(indexToSting(firstIndex) + indexToSting(twoIndex), randomValues)
    
    let signs = signsString.split(",")
    let count = 
        (if sigVerify(toBytes(msg), fromBase58String(signs[firstIndex]), fromBase58String(validators[firstIndex])) then 1 else 0) +
        (if sigVerify(toBytes(msg), fromBase58String(signs[twoIndex]), fromBase58String(validators[twoIndex])) then 1 else 0) +
        (if sigVerify(toBytes(msg), fromBase58String(signs[threeIndex]), fromBase58String(validators[threeIndex])) then 1 else 0) 

    count > 3
}

func createAsset(name: String, description: String, decimals: Int) = {
    let issue = Issue(name, description, 2, decimals, true, unit, 0)
    toBase58String(calculateAssetId(issue))
}
func createDataAssetId(erc20Address: String, assetId: String, name: String, description: String, decimals: Int) = {
    [
        StringEntry(getAssetIdByERC20Key(erc20Address), assetId),
        IntegerEntry(getAssetDecimalsKey(assetId), decimals)
    ]
}

#-------------------Callable---------------------------

@Callable(i)
func mint(rqHash: String, erc20Address: String, owner: String, amount: Int, signsString: String, initDataOrNull: String) = {
    let storageAssetId = getAssetIdByERC20(erc20Address)
    let dataArgs = initDataOrNull.split(SEPARATOR)
    let assetId = if storageAssetId == "" then createAsset(dataArgs[0], dataArgs[1], parseIntValue(dataArgs[2])) else storageAssetId
    let assetCreateResult = 
        if storageAssetId == "" 
            then createDataAssetId(erc20Address, assetId, dataArgs[0], dataArgs[1], parseIntValue(dataArgs[2]))
        else []
    
    [
        ScriptTransfer(addressFromStringValue(owner), amount, fromBase58String(assetId))
    ] ++ assetCreateResult
}


@Callable(i)
func createBurnRequest(target: String) = {
    let pmtSwap = extract(i.payments[0]);
    let pmtFee = extract(i.payments[1]);

    let requestId = toBase58String(keccak256(fromBase58String(toString(this)) + i.caller.bytes + i.transactionId + toBytes(target)))

    let assetId = if isDefined(pmtSwap.assetId) then toBase58String(value(pmtSwap.assetId)) else WAVES
    let amount =  pmtSwap.amount 
    let owner = toString(i.caller)

    if (!isDefined(pmtFee.assetId))
        then throw("invalid fer asset")
    else if (pmtFee.amount < fee)
        then throw("invalid fer asset")
    else if(getRqOwner(requestId) != "")
        then throw("request exists")
    else if(amount == 0)
        then throw("invalid amount")
    else {
        [
            StringEntry(FirstElementKey, if firstElement == "" then requestId else firstElement),
            StringEntry(getNextRqKey(lastElement), if firstElement == "" then "" else requestId),
            StringEntry(getPrevRqKey(requestId), if firstElement == "" then "" else requestId),
            StringEntry(LastElementKey, requestId),

            IntegerEntry(getRqStatusKey(requestId), NEW),
            StringEntry(getRqOwnerKey(requestId), owner),
            StringEntry(getRqAssetIdKey(requestId), assetId),

            IntegerEntry(getRqHeightKey(requestId), height),
            StringEntry(getRqTargetKey(requestId), target),
            IntegerEntry(getRqAmountKey(requestId), amount)
        ]
    }
}

@Callable(i)
func changeStatus(requestId: String, signsString: String, status: Int) = {
    if(!isValidSigns(requestId + "_" + toString(status), signsString)) 
        then throw("count is less bftCoefficien")
    else if(getRqOwner(requestId) == "")
        then throw("request is not exists")
    else if(getRqStatus(requestId) != NEW)
        then throw("request is not exists")
    else if(isRqPastDue(requestId))
        then throw("rq expire")
    else if(status != SUCCESS && status != REJECTED)
        then throw("invalid status")
    else {
        let owner = addressFromStringValue(getRqOwner(requestId))
        let amount = getRqAmount(requestId)

        let assetId = getRqAssetId(requestId)
        let transfer = 
            if status == REJECTED
                then [ ScriptTransfer(addressFromStringValue(getRqOwner(requestId)), getRqAmount(requestId), 
                            if assetId == WAVES then unit else fromBase58String(getRqAssetId(requestId))) ]
            else []

        [
            IntegerEntry(getRqStatusKey(requestId), status)
            
        ] ++ transfer
    }
}

@Callable(i)
func withdrawPastDueReqest(requestId: String) = {
    if(!isRqPastDue(requestId))
        then throw("rq not expire")
    else if(getRqStatus(requestId) != NEW)
        then throw("request not exists")
    else {
        let assetId = getRqAssetId(requestId)
        [
            IntegerEntry(getRqStatusKey(requestId), RETURNED),
            ScriptTransfer(addressFromStringValue(getRqOwner(requestId)), getRqAmount(requestId), if assetId == WAVES then unit else fromBase58String(getRqAssetId(requestId)))
        ]
    }
}
