{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#
# Smart Contract Implementing Bonds Auction in the Orderbook of Neutrino Protocol 
#

#-------------------Constants---------------------------
let WAVES = "WAVES"
let SEPARATOR = ","
#-------------------Base functions----------------------
func getIntegerByKey(key: String) = {
    valueOrElse(getInteger(this, key), 0)
}
func getStringByKey(key: String) = {
    valueOrElse(getString(this, key), "")
}
func getStringByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getString(contract, key), "")
}
func getIntegerByAddressAndKey(contract: Address, key: String) = {
    valueOrElse(getInteger(contract, key), 0)
}


#------Order statuses------
let NONE = 0
let NEW = 1
let REJECTED = 2
let SUCCESS = 3
let RETURNED = 4

let LOCK = 0
let BURN = 1

let INTERNAL = 1
let EXTERNAL = 2
#-------------------Constructo--------------------------
let ValidatorsKey = "validator"
#let BftCoefficientKey = "bft_coefficient"
let RequestTimeoutKey = "rq_timeout"
let FeeKey = "fee"
let RandomContractAddressKey = "random_contact_address"
# erc20_address_WAVES = ercTokenAddress
# asset_type__WAVES = 0 (NativeToken)
# asset_status_WAVES = 3 (SUCCESS)
# asset_decimals__WAVES = 8 

#-------------------Keys--------------------------------
let FirstValidatorKey = "first_validator"
let LastValidatoKey = "last_validator"
let ActiveValidatorsKey = "active_validators"
let TotalGravityKey = "total_gravity"

let TimeoutNewRoundKey = "timeout_new_round"
let RoundEndKey = "round_end"
let RandomKey = "random_key"

func getNextValidatorKey(address: String) = "next_validator_" + address
func getPrevValidatorKey(address: String) = "prev_validator_" + address
func getGravityByValidatorKey(address: String) = "gravity_" + address


#-------------------Global vars-------------------------
let firstValidator = getStringByKey(FirstValidatorKey)
let lastValidator = getStringByKey(LastValidatoKey)
let activeValidators = getStringByKey(ActiveValidatorsKey).split(",")
let totalGravity = getIntegerByKey(TotalGravityKey)

let randomContractAddress = addressFromStringValue(getStringByKey(RandomContractAddressKey))
let timeoutNewRound = getIntegerByAddressAndKey(randomContractAddress, TimeoutNewRoundKey)
let roundEnd = getIntegerByAddressAndKey(randomContractAddress, RoundEndKey)
let random = getStringByAddressAndKey(randomContractAddress, RandomKey)

#-------------------Get functions----------------------

# List
# 0 - 1 - 2 - 3
# next counter+1
func getNextValidator(address: String) = getStringByKey(getNextValidatorKey(address))
func getPrevValidator(address: String) = getStringByKey(getPrevValidatorKey(address))
func getGravityByValidator(address: String) = getIntegerByKey(getGravityByValidatorKey(address))


#-------------------Other functions--------------------
func indexToString(index: Int) = {
    "|" + toString(index) + "|"
}

func getDropedList(freeValidators: List[Int], dropIndex: Int) = {
    [] 
        ++ (if size(freeValidators) > 0 && freeValidators[0] == dropIndex then [] else [ freeValidators[0] ]) 
        ++ (if size(freeValidators) > 1 && freeValidators[1] == dropIndex then [] else [ freeValidators[1] ]) 
        ++ (if size(freeValidators) > 2 && freeValidators[2] == dropIndex then [] else [ freeValidators[2] ]) 
        ++ (if size(freeValidators) > 3 && freeValidators[3] == dropIndex then [] else [ freeValidators[3] ]) 
        ++ (if size(freeValidators) > 4 && freeValidators[4] == dropIndex then [] else [ freeValidators[4] ]) 
}

#-------------------Callable---------------------------

@Callable(i)
func selectNewValidators() = {
    let bytesRandom = fromBase58String(random)
    let randomValues = [
        toInt(take(bytesRandom, 8)),
        toInt(take(drop(bytesRandom, 8),8)),
        toInt(take(drop(bytesRandom, 16),8))
    ]

    let startValidators = [
        0,
        1,
        2,
        3,
        4
    ]

    let firstValidatorIndex = randomValues[0] % 5
    let validatorsOne = getDropedList(startValidators, firstValidatorIndex)
    let twoValidatorIndex =  randomValues[1] % 4

    let validatorsTwo = getDropedList(startValidators, firstValidatorIndex)
    let threeValidatorIndex = randomValues[2] % 3


    let one = startValidators[firstValidatorIndex]
    let two = validatorsOne[twoValidatorIndex]
    let three = validatorsTwo[threeValidatorIndex]
    
    
}
